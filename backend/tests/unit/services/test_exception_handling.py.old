"""
异常处理单元测试 - 专门测试系统异常和业务异常的处理
"""
import pytest
import asyncio
import json
from unittest.mock import Mock, patch, AsyncMock
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.services.task_processor import TaskProcessor
from app.services.document_processor import DocumentProcessor
from app.services.issue_detector import IssueDetector
from tests.fixtures.mock_helpers import create_mock_dependencies, MockAIService


class TestExceptionHandling:
    """异常处理测试类"""
    
    @pytest.fixture
    def mock_db(self):
        """Mock数据库会话"""
        db = Mock()
        db.add = Mock()
        db.commit = Mock()
        db.rollback = Mock()
        return db
    
    @pytest.fixture
    def mock_deps(self):
        """创建Mock依赖"""
        return create_mock_dependencies()
    
    @pytest.fixture
    def mock_model_config(self):
        """Mock模型配置"""
        return {
            'provider': 'openai',
            'config': {
                'api_key': 'test-api-key',
                'base_url': 'https://api.openai.com/v1',
                'model': 'gpt-4o-mini'
            }
        }


class TestTaskProcessorExceptions(TestExceptionHandling):
    """TaskProcessor异常处理测试"""
    
    @pytest.fixture
    def task_processor(self, mock_db, mock_deps):
        """创建TaskProcessor实例"""
        processor = TaskProcessor(mock_db)
        
        # 注入Mock依赖
        processor.task_repo = mock_deps['task_repo']
        processor.file_repo = mock_deps['file_repo']
        processor.issue_repo = mock_deps['issue_repo']
        processor.ai_output_repo = mock_deps['ai_output_repo']
        processor.model_repo = mock_deps['model_repo']
        processor.ai_service_factory = mock_deps['ai_service_factory']
        processor.websocket_manager = mock_deps['websocket_manager']
        
        return processor
    
    @pytest.mark.asyncio
    async def test_database_connection_error(self, task_processor, mock_deps):
        """测试数据库连接错误"""
        task_id = 1
        mock_task = mock_deps['task_repo'].create_mock_task(task_id=task_id)
        
        # 配置数据库操作抛出异常
        task_processor.task_repo.get.return_value = mock_task
        task_processor.task_repo.update.side_effect = SQLAlchemyError("数据库连接失败")
        
        # 执行测试
        await task_processor.process_task(task_id)
        
        # 验证错误处理：应该尝试回滚
        mock_deps['websocket_manager'].send_status.assert_called()
        # 验证错误状态被发送
        error_messages = [
            call for call in mock_deps['websocket_manager'].sent_messages 
            if 'error' in str(call).lower()
        ]
        assert len(error_messages) > 0
    
    @pytest.mark.asyncio
    async def test_file_not_readable_error(self, task_processor, mock_deps):
        """测试文件不可读异常"""
        task_id = 1
        mock_task = mock_deps['task_repo'].create_mock_task(task_id=task_id)
        mock_file = mock_deps['file_repo'].create_mock_file(
            task_id=task_id,
            file_path='/nonexistent/file.txt'
        )
        
        # 配置Mock
        task_processor.task_repo.get.return_value = mock_task
        task_processor.file_repo.get_by_task_id.return_value = mock_file
        task_processor.model_repo.get_by_id.return_value = Mock()
        
        # Mock文件读取失败
        with patch('builtins.open', side_effect=FileNotFoundError("文件不存在")):
            await task_processor.process_task(task_id)
            
            # 验证错误处理
            task_processor.task_repo.update.assert_called_with(task_id, status="failed")
    
    @pytest.mark.asyncio
    async def test_ai_service_timeout_error(self, task_processor, mock_deps):
        """测试AI服务超时异常"""
        task_id = 1
        mock_task = mock_deps['task_repo'].create_mock_task(task_id=task_id)
        mock_file = mock_deps['file_repo'].create_mock_file(task_id=task_id)
        
        # 配置AI服务超时
        mock_ai_service = MockAIService()
        mock_ai_service.set_failure(should_fail=True, fail_count=999)  # 持续失败
        task_processor.ai_service_factory.get_service.return_value = mock_ai_service
        
        # 重新定义analyze_document方法抛出超时异常
        async def timeout_error(*args, **kwargs):
            raise asyncio.TimeoutError("AI服务调用超时")
        
        mock_ai_service.analyze_document = timeout_error
        
        # 配置其他依赖
        task_processor.task_repo.get.return_value = mock_task
        task_processor.file_repo.get_by_task_id.return_value = mock_file
        task_processor.model_repo.get_by_id.return_value = Mock()
        
        with patch('builtins.open', mock_open_read('测试内容')):
            await task_processor.process_task(task_id)
            
            # 验证超时异常被处理
            task_processor.task_repo.update.assert_called_with(task_id, status="failed")
    
    @pytest.mark.asyncio
    async def test_websocket_connection_error(self, task_processor, mock_deps):
        """测试WebSocket连接错误"""
        task_id = 1
        mock_task = mock_deps['task_repo'].create_mock_task(task_id=task_id)
        
        # 配置WebSocket发送失败
        async def websocket_error(*args, **kwargs):
            raise ConnectionError("WebSocket连接断开")
        
        mock_deps['websocket_manager'].send_status = websocket_error
        
        # 配置其他依赖
        task_processor.task_repo.get.return_value = mock_task
        task_processor.file_repo.get_by_task_id.return_value = None  # 文件不存在
        
        # 执行测试 - WebSocket错误不应该阻止任务处理
        await task_processor.process_task(task_id)
        
        # 验证任务状态仍然被更新（即使WebSocket失败）
        task_processor.task_repo.update.assert_called()


class TestDocumentProcessorExceptions(TestExceptionHandling):
    """DocumentProcessor异常处理测试"""
    
    @pytest.fixture
    def document_processor(self, mock_model_config, mock_db):
        """创建DocumentProcessor实例"""
        with patch('app.services.document_processor.ChatOpenAI'):
            with patch('app.services.document_processor.PydanticOutputParser'):
                return DocumentProcessor(mock_model_config, mock_db)
    
    @pytest.mark.asyncio
    async def test_ai_model_initialization_failure(self, mock_model_config, mock_db):
        """测试AI模型初始化失败"""
        with patch('app.services.document_processor.ChatOpenAI', side_effect=Exception("模型初始化失败")):
            with pytest.raises(Exception, match="模型初始化失败"):
                DocumentProcessor(mock_model_config, mock_db)
    
    @pytest.mark.asyncio
    async def test_prompt_loader_failure(self, document_processor):
        """测试提示词加载失败"""
        test_text = "测试文档内容"
        
        with patch('app.services.document_processor.prompt_loader') as mock_loader:
            mock_loader.get_system_prompt.side_effect = KeyError("提示词模板不存在")
            
            # 执行测试
            result = await document_processor.preprocess_document(test_text)
            
            # 验证错误被处理，返回默认结果
            assert len(result) == 1
            assert result[0]['content'] == test_text
    
    @pytest.mark.asyncio
    async def test_database_commit_failure(self, document_processor, mock_db):
        """测试数据库提交失败"""
        test_text = "测试内容"
        task_id = 1
        
        # 配置数据库提交失败
        mock_db.commit.side_effect = IntegrityError("", "", "")
        
        # Mock AI响应
        mock_response = {"sections": [{"section_title": "测试", "content": "内容", "level": 1}]}
        
        with patch.object(document_processor, '_call_ai_model') as mock_call:
            mock_call.return_value = Mock(content=json.dumps(mock_response))
            
            # 执行测试 - 数据库错误不应影响处理结果
            result = await document_processor.preprocess_document(test_text, task_id)
            
            # 验证仍返回正确结果
            assert len(result) == 1
            assert result[0]['section_title'] == '测试'
    
    @pytest.mark.asyncio
    async def test_json_parsing_corruption(self, document_processor):
        """测试JSON解析损坏"""
        test_text = "测试内容"
        
        # Mock返回损坏的JSON
        corrupted_json = '{"sections": [{"title": "测试", "content": "内容", "level": 1'  # 缺少闭合括号
        
        with patch.object(document_processor, '_call_ai_model') as mock_call:
            mock_call.return_value = Mock(content=corrupted_json)
            
            # 执行测试
            result = await document_processor.preprocess_document(test_text)
            
            # 验证错误被处理，返回默认结果
            assert len(result) == 1
            assert result[0]['content'] == test_text


class TestIssueDetectorExceptions(TestExceptionHandling):
    """IssueDetector异常处理测试"""
    
    @pytest.fixture
    def issue_detector(self, mock_model_config, mock_db):
        """创建IssueDetector实例"""
        with patch('app.services.issue_detector.ChatOpenAI'):
            with patch('app.services.issue_detector.PydanticOutputParser'):
                return IssueDetector(mock_model_config, mock_db)
    
    @pytest.mark.asyncio
    async def test_concurrent_ai_failures(self, issue_detector, mock_db):
        """测试并发AI调用失败"""
        sections = [
            {"section_title": f"章节{i}", "content": "足够长的内容" * 10, "level": 1}
            for i in range(3)
        ]
        
        # Mock并发AI调用失败
        call_count = [0]
        async def failing_ai_call(*args, **kwargs):
            call_count[0] += 1
            if call_count[0] <= 2:  # 前两次调用失败
                raise ConnectionError(f"AI服务连接失败 #{call_count[0]}")
            else:
                # 第三次调用成功
                return Mock(content='{"issues": []}')
        
        with patch.object(issue_detector, '_call_ai_model', side_effect=failing_ai_call):
            result = await issue_detector.detect_issues(sections, task_id=1)
            
            # 验证部分失败不影响整体处理
            assert result == []  # 所有章节要么失败要么返回空问题
            
            # 验证错误被记录到数据库
            assert mock_db.add.call_count >= 2  # 至少记录了失败的调用
    
    @pytest.mark.asyncio
    async def test_memory_exhaustion_simulation(self, issue_detector):
        """测试内存耗尽模拟"""
        # 创建大量章节模拟内存压力
        large_sections = [
            {
                "section_title": f"大章节{i}",
                "content": "非常长的内容" * 1000,  # 模拟大量内容
                "level": 1
            }
            for i in range(100)  # 大量章节
        ]
        
        # Mock AI调用抛出内存错误
        with patch.object(issue_detector, '_call_ai_model', side_effect=MemoryError("内存不足")):
            result = await issue_detector.detect_issues(large_sections)
            
            # 验证内存错误被处理
            assert result == []
    
    @pytest.mark.asyncio
    async def test_malformed_response_handling(self, issue_detector):
        """测试处理格式错误的响应"""
        sections = [{"section_title": "测试", "content": "测试内容" * 10, "level": 1}]
        
        # 模拟各种格式错误的响应
        malformed_responses = [
            None,  # 空响应
            Mock(content=None),  # content为None
            Mock(content=""),  # 空内容
            Mock(content="非JSON文本"),  # 非JSON
            Mock(content='{"issues":}'),  # 无效JSON语法
            Mock(content='{"wrong_key": []}'),  # 错误的键名
        ]
        
        for response in malformed_responses:
            with patch.object(issue_detector, '_call_ai_model', return_value=response):
                result = await issue_detector.detect_issues(sections)
                
                # 验证所有格式错误都被正确处理
                assert result == []
    
    def test_filter_issues_edge_cases(self, issue_detector):
        """测试问题过滤的边界情况"""
        edge_case_issues = [
            {},  # 空字典
            {"type": "问题", "confidence": "not_a_number"},  # 置信度不是数字
            {"type": "问题", "confidence": -0.5},  # 负数置信度
            {"type": "问题", "confidence": 1.5},  # 超过1.0的置信度
            {"type": "问题", "confidence": float('nan')},  # NaN置信度
            {"type": "问题", "confidence": float('inf')},  # 无穷大置信度
        ]
        
        # 测试不应该抛出异常
        result = issue_detector.filter_issues_by_severity(edge_case_issues, min_confidence=0.5)
        
        # 验证边界情况被正确处理
        assert isinstance(result, list)
    
    def test_categorize_issues_edge_cases(self, issue_detector):
        """测试问题分类的边界情况"""
        edge_case_issues = [
            {},  # 空字典
            {"type": "问题", "severity": None},  # severity为None
            {"type": "问题", "severity": ""},  # 空字符串severity
            {"type": "问题", "severity": 123},  # 非字符串severity
            {"type": "问题", "severity": "未知等级"},  # 未定义的严重等级
        ]
        
        # 测试不应该抛出异常
        result = issue_detector.categorize_issues(edge_case_issues)
        
        # 验证边界情况被正确处理
        assert isinstance(result, dict)
        assert all(key in result for key in ['致命', '严重', '一般', '提示'])


# 测试辅助函数
def mock_open_read(read_data=''):
    """创建mock open函数用于读取"""
    mock_file = Mock()
    mock_file.__enter__ = Mock(return_value=Mock())
    mock_file.__exit__ = Mock(return_value=None)
    mock_file.__enter__.return_value.read = Mock(return_value=read_data)
    return Mock(return_value=mock_file)